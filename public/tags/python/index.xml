<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on (*´･д･)?</title>
    <link>http://xrazor.org/tags/python/</link>
    <description>Recent content in Python on (*´･д･)?</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 21 Aug 2016 23:26:03 +0800</lastBuildDate>
    
	<atom:link href="http://xrazor.org/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>计算机字符编码手扎</title>
      <link>http://xrazor.org/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%89%8B%E6%89%8E/</link>
      <pubDate>Sun, 21 Aug 2016 23:26:03 +0800</pubDate>
      
      <guid>http://xrazor.org/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%89%8B%E6%89%8E/</guid>
      <description>基础知识 首先，计算机编码的结构为:
二进制位（Bit）——二进制字符串——字节（8 Bit） 众所周知，二进制是计算机信息表达的基础。每个Bit有0和1两种状态，8个二进制位就可以有256种状态，称为1个字节。
ASCii编码 有了上面的设定，人们就想了——怎么把日常的信息转化位计算机的执行语言呢？即建立计算机语言和人类语言的桥梁。 于是ASCii出现了，它规定了128个二进制字符串，使之与英文字母等常用字符一一对应。比如大写字母A对应的二进制字符串是01000001。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。
Unicode 慢慢的，不光是英文需要与计算机语言桥接，法语日语中文俄文也要啊！所以你搞一个编码我搞一个编码，纷纷把自己的语言和计算机语言联系起来。结果悲剧了，不同的编码方式导致了解码的时候得到的信息不一致。法文编码的用日文的解码方式得出来一堆乱码。怎么办？ 为解决这个问题，Unicode应运而生。它包含了世界上所有文字符号，每个符号都有一个独一无二的编码。这样就不会出现乱码的问题了。它是类似这样的：&amp;amp;#x0041（表示大写字母A）。 但是，Unicode并不是没有问题。它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 比如，汉字”严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。这样计算机就迷茫了。如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？另一个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用四个字节表示，那么每个英文字母前都必然有三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。
UTF-8 因此大家需要一个通用的Unicode的实现方式，UTF-8就此出现。 它的前提思想就是用第一个字节来告诉计算机——“我是多少字符表示的符号“。因此它是一种可变长的编码方式，字符可以用单字符（英文）也可用双字符（中文）甚至更多的字符（更大的符号）来表示。 它的规则如下：
1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。
2）对于n字节的符号（n&amp;gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。 下表总结了编码规则，字母x表示可用编码的位。
Unicode符号范围 | UTF-8编码方式 (十六进制) | （二进制） --------------------+--------------------------------------------- 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx  跟据上表，解读UTF-8编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。 下面，还是以汉字”严”为例，演示如何实现UTF-8编码。 已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101”。
Python中编码的处理 首先就要弄清础，你想搞的对象是啥？是str？还是Unicode，这样你才能知道是用encode还是decode。
isinstance(&#39;object&#39;,str) instance(&#39;object&#39;,unicode)  不要对str使用encode，不要对unicode使用decode。</description>
    </item>
    
  </channel>
</rss>